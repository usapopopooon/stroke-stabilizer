# フィルタリファレンス

[English](./filters.md)

このドキュメントでは、stroke-stabilizerで利用可能なすべてのフィルタとカーネルについて、数学的な基礎と実用的な用途を含めて詳しく説明します。

## 目次

### リアルタイムフィルタ

- [ノイズフィルタ](#ノイズフィルタ)
- [移動平均フィルタ](#移動平均フィルタ)
- [EMAフィルタ（指数移動平均）](#emaフィルタ指数移動平均)
- [カルマンフィルタ](#カルマンフィルタ)
- [One Euroフィルタ](#one-euroフィルタ)
- [ストリングフィルタ（Lazy Brush）](#ストリングフィルタlazy-brush)
- [線形予測フィルタ](#線形予測フィルタ)

### ポストプロセスカーネル

- [ガウシアンカーネル](#ガウシアンカーネル)
- [ボックスカーネル](#ボックスカーネル)
- [トライアングルカーネル](#トライアングルカーネル)
- [バイラテラルカーネル](#バイラテラルカーネル)

### 概念

- [FIRフィルタとIIRフィルタ](#firフィルタとiirフィルタ)
- [畳み込みとパディング](#畳み込みとパディング)

---

## リアルタイムフィルタ

リアルタイムフィルタは各入力点をO(1)の時間計算量で即座に処理し、ライブ描画アプリケーションに適しています。

### ノイズフィルタ

**目的：** 近すぎる点を除去し、高周波のジッター（細かい揺れ）を排除します。

**仕組み：**

ノイズフィルタは最後に受け入れた点を保持し、最小距離閾値内の新しい点を拒否します。

```
if 距離(現在の点, 最後に受け入れた点) < 最小距離:
    点を拒否
else:
    点を受け入れ
```

**数式：**

$$d = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}$$

$d$ は連続する点間のユークリッド距離です。

**パラメータ：**

| パラメータ    | 型     | デフォルト | 説明                           |
| ------------- | ------ | ---------- | ------------------------------ |
| `minDistance` | number | 2          | 点間の最小距離（ピクセル単位） |

**目安：**

- 2.0：標準的な設定。細かいジッタを除去しつつ精度を維持
- 5.0以上：粗い入力向け。点数が減りすぎる可能性あり

**使用場面：**

- 入力に微小な震えやジッターがある場合
- パイプラインの最初のフィルタとして不要な点を減らす場合
- スムージングなしで点数を減らしたい場合

**例：**

```ts
import { noiseFilter } from '@stroke-stabilizer/core'

// 3ピクセル未満の点を拒否
const filter = noiseFilter({ minDistance: 3 })
```

---

### 移動平均フィルタ

**目的：** 直近N点の単純移動平均（SMA）で入力をスムーズにします。

**仕組み：**

これは**FIR（有限インパルス応答）フィルタ**で、直近N点を等しい重みで平均します。

**数式：**

$$\bar{x}_n = \frac{1}{N} \sum_{i=0}^{N-1} x_{n-i}$$

ここで：

- $\bar{x}_n$ は時刻 $n$ でのスムーズ化された出力
- $N$ はウィンドウサイズ
- $x_{n-i}$ は過去の入力点

**パラメータ：**

| パラメータ   | 型     | デフォルト | 説明                           |
| ------------ | ------ | ---------- | ------------------------------ |
| `windowSize` | number | 5          | 平均する点の数                 |
| `weights`    | array  | 均等       | カスタム重み配列（オプション） |

**特性：**

- **遅延：** $(N-1)/2$ 点分の遅れ
- **滑らかさ：** Nが大きいほど滑らかだが遅延も大きい
- **メモリ：** 直近N点を保存

**使用場面：**

- シンプルなスムージング要件
- 一貫した予測可能な動作が必要な場合
- 教育目的（理解しやすい）

**例：**

```ts
import { movingAverageFilter } from '@stroke-stabilizer/core'

// 7点移動平均
const filter = movingAverageFilter({ windowSize: 7 })

// カスタム重み付き移動平均（中心重視）
const weighted = movingAverageFilter({
  windowSize: 5,
  weights: [0.1, 0.2, 0.4, 0.2, 0.1],
})
```

---

### EMAフィルタ（指数移動平均）

**目的：** 古い値に対して指数関数的に減少する重みで入力をスムーズにし、低遅延のスムージングを提供します。

**仕組み：**

これは**IIR（無限インパルス応答）フィルタ**で、各出力は前の出力と現在の入力に依存します。最近の値が古い値よりも大きな影響を持ちます。

**数式：**

$$y_n = \alpha \cdot x_n + (1 - \alpha) \cdot y_{n-1}$$

ここで：

- $y_n$ は時刻 $n$ でのスムーズ化された出力
- $x_n$ は現在の入力
- $\alpha$ はスムージング係数（0 < α ≤ 1）
- $y_{n-1}$ は前の出力

**パラメータ：**

| パラメータ | 型     | デフォルト | 説明                                        |
| ---------- | ------ | ---------- | ------------------------------------------- |
| `alpha`    | number | 0.5        | スムージング係数（0-1）。高いほど応答性向上 |

**alphaの理解：**

- $\alpha = 1.0$：スムージングなし（出力 = 入力）
- $\alpha = 0.5$：中程度のスムージング
- $\alpha = 0.1$：強いスムージング（応答が遅い）

**特性：**

- **遅延：** 同等のスムージングの移動平均より低遅延
- **メモリ：** 前の値1つだけを保存（O(1)空間）
- **インパルス応答：** 指数関数的に減衰し、真にゼロにはならない

**使用場面：**

- 低遅延が求められる場合
- メモリ制約のある環境
- 単一パラメータで調整可能なスムージングが必要な場合

**例：**

```ts
import { emaFilter } from '@stroke-stabilizer/core'

// 中程度のスムージング
const filter = emaFilter({ alpha: 0.5 })

// 非常に滑らか（遅延大）
const smooth = emaFilter({ alpha: 0.2 })

// 非常に応答性が高い（滑らかさ低）
const responsive = emaFilter({ alpha: 0.8 })
```

---

### カルマンフィルタ

**目的：** 位置のみのモデルを使用したノイズ入力に対する最適な状態推定。

**仕組み：**

カルマンフィルタはノイズのある測定値からシステムの真の状態を推定する再帰的アルゴリズムです。次の状態を予測する内部モデルを維持し、実際の測定に基づいてこの予測を修正します。

**数学モデル：**

この実装では、高周波入力デバイス（144Hz以上）での安定性のために、速度を使用しないシンプルな位置のみのモデルを採用しています。

**予測ステップ：**

$$\hat{x}_{k|k-1} = \hat{x}_{k-1|k-1}$$
$$P_{k|k-1} = P_{k-1|k-1} + Q$$

**更新ステップ：**

$$K_k = \frac{P_{k|k-1}}{P_{k|k-1} + R}$$
$$\hat{x}_{k|k} = \hat{x}_{k|k-1} + K_k \cdot (z_k - \hat{x}_{k|k-1})$$

ここで：

- $Q$ はプロセスノイズ共分散
- $R$ は測定ノイズ共分散
- $K_k$ はカルマンゲイン
- $z_k$ は測定値

**パラメータ：**

| パラメータ         | 型     | デフォルト | 説明                    |
| ------------------ | ------ | ---------- | ----------------------- |
| `processNoise`     | number | 0.1        | 動きの予想分散（Q）     |
| `measurementNoise` | number | 0.5        | 入力測定の予想分散（R） |

**目安（strengthで指定する場合）：**

exampleでは0〜100のstrength値を以下の式で変換しています：

```ts
const t = strength / 100
processNoise: 1.0 - t * 0.9      // 1.0 → 0.1
measurementNoise: 0.05 + t * 0.95 // 0.05 → 1.0
```

- strength 10：軽い補正。応答性を維持しつつ微振動を除去
- strength 30〜50：標準的な設定。バランスの取れたスムージング
- strength 80以上：強い補正。遅延が目立つが非常に滑らか

**パラメータの理解：**

- **高いprocessNoise：** 急激で予測不能な動きを想定 → より応答性が高い
- **高いmeasurementNoise：** ノイズの多い入力を想定 → よりスムージング
- **比率が重要：** `measurementNoise / processNoise` がスムージングレベルを決定

**特性：**

- **最適：** ガウスノイズ仮定下での平均二乗誤差を最小化
- **適応的：** カルマンゲインが予測と測定への信頼度に基づいて調整
- **安定：** 位置のみのモデルにより、高周波入力でも暴走しない

**使用場面：**

- 手の震えによるノイズの多い入力
- 入力品質に応じた適応的スムージングが必要な場合
- 最適推定が必要な科学/工学アプリケーション

**例：**

```ts
import { kalmanFilter } from '@stroke-stabilizer/core'

// デフォルト設定
const filter = kalmanFilter()

// 入力をより信頼（スムージング少）
const responsive = kalmanFilter({
  processNoise: 0.5,
  measurementNoise: 0.2,
})

// 入力をあまり信頼しない（スムージング多）
const smooth = kalmanFilter({
  processNoise: 0.05,
  measurementNoise: 1.0,
})
```

---

### One Euroフィルタ

**目的：** 低速時は滑らかな出力、高速時は応答性の高い出力を提供する速度適応型ローパスフィルタ。

**仕組み：**

One Euroフィルタは適応型1次ローパスフィルタです。入力速度に基づいてカットオフ周波数を動的に調整します：ゆっくり動いているときは低いカットオフ（よりスムージング）、速く動いているときは高いカットオフ（スムージング少、遅延少）を使用します。

**数式：**

フィルタは適応的なalphaによる指数スムージングを使用：

$$\alpha = \frac{1}{1 + \frac{\tau}{T_e}}$$

ここで：

- $\tau = \frac{1}{2\pi f_c}$（時定数）
- $f_c$ はカットオフ周波数
- $T_e$ はサンプル間の時間

カットオフ周波数は速度に基づいて適応：

$$f_c = f_{c,min} + \beta \cdot |\dot{x}|$$

ここで：

- $f_{c,min}$ は最小カットオフ周波数
- $\beta$ は速度係数
- $|\dot{x}|$ は絶対微分（速度）

**パラメータ：**

| パラメータ  | 型     | デフォルト | 説明                                       |
| ----------- | ------ | ---------- | ------------------------------------------ |
| `minCutoff` | number | 1.0        | 最小カットオフ周波数（Hz）。低いほど滑らか |
| `beta`      | number | 0.007      | 速度係数。高いほど応答性向上               |
| `dCutoff`   | number | 1.0        | 微分用カットオフ周波数（通常1.0）          |

**チューニングガイド：**

1. `beta = 0` から始め、低速時の望ましいスムージングになるよう `minCutoff` を調整
2. 高速時の遅延を減らすために `beta` を増加
3. 用途に合わせて両パラメータを微調整

**特性：**

- **適応的：** 高速時は遅延少、低速時はスムージング多
- **低遅延：** スムージングと遅延の比率が最も優れている
- **シンプル：** 調整するパラメータは3つだけ

**使用場面：**

- 描画アプリケーション（推奨デフォルト）
- スムージングと応答性の最適なバランスが必要な場合
- 署名キャプチャ、手書き入力

**例：**

```ts
import { oneEuroFilter } from '@stroke-stabilizer/core'

// デフォルト設定（良い出発点）
const filter = oneEuroFilter({
  minCutoff: 1.0,
  beta: 0.007,
})

// 低速時により滑らか
const smooth = oneEuroFilter({
  minCutoff: 0.5,
  beta: 0.007,
})

// 高速時により応答性が高い
const responsive = oneEuroFilter({
  minCutoff: 1.0,
  beta: 0.02,
})
```

**参考文献：** Casiez, G., Roussel, N., & Vogel, D. (2012). "1€ Filter: A Simple Speed-based Low-pass Filter for Noisy Input in Interactive Systems"

---

### ストリングフィルタ（Lazy Brush）

**目的：** 出力が固定長の紐で接続されているかのように入力に遅れて追従する「引っ張られた紐」効果を作成します。

**仕組み：**

出力点が固定長の紐で入力点に接続されていると想像してください。出力は入力が十分遠くなって「引っ張る」ときだけ移動します。これにより、ジッターが減少した滑らかで意図的なストロークが作成されます。

**数学モデル：**

```
距離 = |入力 - 出力|

if 距離 > 紐の長さ:
    方向 = 正規化(入力 - 出力)
    出力 = 入力 - 方向 * 紐の長さ
else:
    出力はその場にとどまる
```

**パラメータ：**

| パラメータ     | 型     | デフォルト | 説明                         |
| -------------- | ------ | ---------- | ---------------------------- |
| `stringLength` | number | 10         | 仮想紐の長さ（ピクセル単位） |

**目安：**

- 5〜10：軽い補正。自然な追従感
- 15〜30：強めの補正。滑らかだが遅延が目立つ
- 50以上：書道向け。非常に意図的なストロークになる

**特性：**

- **意図的な遅延：** 出力は意図的に後ろから追従
- **方向スムージング：** 紐の長さより小さい方向変化を排除
- **ジッターなし：** 小さな動きは完全にフィルタリング

**使用場面：**

- 意図的で滑らかなストロークが望ましい芸術的描画
- 「引っ張られた筆」の感触が欲しい場合
- 書道アプリケーション

**例：**

```ts
import { stringFilter } from '@stroke-stabilizer/core'

// 短い紐（繊細な効果）
const subtle = stringFilter({ stringLength: 5 })

// 長い紐（強い効果、より意図的）
const strong = stringFilter({ stringLength: 20 })
```

**別名：** Lazy Brush、Pulled String Stabilizer

---

### 線形予測フィルタ

**目的：** 速度に基づいて次の位置を予測し、フィルタ遅延を補正します。

**仕組み：**

このフィルタは最近の点から速度を推定し、入力が「あるべき」位置を予測して、パイプライン内の他のフィルタによる遅延を補正します。

**数式：**

$$\hat{x}_{n+1} = x_n + v_n \cdot k$$

ここで：

- $\hat{x}_{n+1}$ は予測位置
- $x_n$ は現在の位置
- $v_n$ は推定速度
- $k$ は予測係数

速度は履歴に対する線形回帰を使って推定：

$$v = \frac{\sum_{i=1}^{N} (x_i - x_{i-1}) / \Delta t_i}{N}$$

**パラメータ：**

| パラメータ         | 型     | デフォルト | 説明                          |
| ------------------ | ------ | ---------- | ----------------------------- |
| `historySize`      | number | 4          | 速度推定用の点数              |
| `predictionFactor` | number | 0.5        | どれだけ先を予測するか（0-1） |
| `smoothing`        | number | 0.6        | 出力に適用するスムージング    |

**特性：**

- **遅延補正：** 他のフィルタからの知覚遅延を減らせる
- **オーバーシュートリスク：** 高い予測係数は方向変更時にオーバーシュートする可能性
- **組み合わせ最適：** 通常はスムージングフィルタと一緒に使用

**使用場面：**

- 強いスムージングと組み合わせて遅延を減らす
- 応答性が重要なリアルタイム描画
- 他のフィルタの後に遅延を補正する

**例：**

```ts
import { linearPredictionFilter } from '@stroke-stabilizer/core'

// 控えめな予測
const conservative = linearPredictionFilter({
  historySize: 4,
  predictionFactor: 0.3,
  smoothing: 0.7,
})

// 積極的な予測（オーバーシュートの可能性あり）
const aggressive = linearPredictionFilter({
  historySize: 6,
  predictionFactor: 0.7,
  smoothing: 0.4,
})
```

---

## ポストプロセスカーネル

ポストプロセスカーネルはストローク完了後に双方向畳み込みを使用して適用されます。ストローク全体が利用可能なため、リアルタイム処理よりも滑らかな結果が得られます。

### ガウシアンカーネル

**目的：** 自然な見た目のブラーのためにガウス重み付きスムージングを適用します。

**仕組み：**

ガウシアンカーネルは距離に基づいて隣接点に重みを付け、近い点ほど影響力が大きくなります。これにより滑らかで自然な結果が生まれます。

**数式：**

$$G(x) = \frac{1}{\sigma\sqrt{2\pi}} e^{-\frac{x^2}{2\sigma^2}}$$

ここで：

- $\sigma$ は標準偏差
- $x$ は中心からの距離

離散カーネルの場合、重みは計算されて正規化されます：

$$w_i = e^{-\frac{i^2}{2\sigma^2}}$$

**パラメータ：**

| パラメータ | 型     | デフォルト | 説明                           |
| ---------- | ------ | ---------- | ------------------------------ |
| `size`     | number | 5          | カーネルサイズ（奇数）         |
| `sigma`    | number | 自動       | 標準偏差（デフォルト：size/6） |

**目安：**

- size 3：軽い補正。ほぼ元の形を維持
- size 5〜7：標準的な設定。適度に滑らか
- size 11以上：強い補正。角が丸まりやすい

**特性：**

- **滑らかなフォールオフ：** 重みは中心から滑らかに減少
- **周波数応答：** 緩やかなロールオフを持つローパスフィルタ
- **標準的選択：** 最も一般的に使用されるスムージングカーネル

**使用場面：**

- 汎用スムージング
- 自然な見た目の結果が欲しい場合
- ポストプロセスのデフォルト選択

**例：**

```ts
import { gaussianKernel } from '@stroke-stabilizer/core'

// 小さいカーネル（繊細なスムージング）
const subtle = gaussianKernel({ size: 3 })

// 大きいカーネル（強いスムージング）
const strong = gaussianKernel({ size: 11 })

// カスタムシグマ
const custom = gaussianKernel({ size: 7, sigma: 1.5 })
```

---

### ボックスカーネル

**目的：** ウィンドウ上で均一な平均化を適用（単純移動平均）。

**仕組み：**

ウィンドウ内のすべての点が等しい重みを持ちます。シンプルで高速ですが、ガウシアンよりも自然でない結果になる可能性があります。

**数式：**

$$w_i = \frac{1}{N}$$

$N$ はカーネルサイズです。

**パラメータ：**

| パラメータ | 型     | デフォルト | 説明                   |
| ---------- | ------ | ---------- | ---------------------- |
| `size`     | number | 5          | カーネルサイズ（奇数） |

**特性：**

- **均一な重み：** すべての隣接点が等しく寄与
- **よりシャープなエッジ：** ガウシアンよりエッジを保持しやすい
- **高速：** 最もシンプルな計算

**使用場面：**

- 計算速度が重要な場合
- 均一な平均化が特に必要な場合
- 教育目的

**例：**

```ts
import { boxKernel } from '@stroke-stabilizer/core'

const kernel = boxKernel({ size: 5 })
```

---

### トライアングルカーネル

**目的：** 線形フォールオフ重み付けを適用。ボックスとガウシアンの中間。

**仕組み：**

重みは中心からエッジに向かって線形に減少し、ボックスカーネルよりも滑らかな結果を提供しますが、ガウシアンとは異なる特性を持ちます。

**数式：**

$$w_i = 1 - \frac{|i|}{r}$$

$r$ はカーネル半径（サイズの半分）です。

**パラメータ：**

| パラメータ | 型     | デフォルト | 説明                   |
| ---------- | ------ | ---------- | ---------------------- |
| `size`     | number | 5          | カーネルサイズ（奇数） |

**特性：**

- **線形フォールオフ：** 重みは中心から線形に減少
- **中程度のスムージング：** ボックスとガウシアンの間の滑らかさ
- **エッジでゼロ：** ガウシアンと異なり、カーネルエッジで正確にゼロ

**使用場面：**

- ガウシアンが滑らかすぎる場合
- ボックスカーネルが粗すぎる場合
- シンプルで直感的なフォールオフが欲しい場合

**例：**

```ts
import { triangleKernel } from '@stroke-stabilizer/core'

const kernel = triangleKernel({ size: 7 })
```

---

### バイラテラルカーネル

**目的：** 緩やかなカーブを滑らかにしながら鋭角を維持するエッジ保存スムージング。

**仕組み：**

バイラテラルカーネルは空間的距離（ガウシアンと同様）と値の類似性の両方を考慮します。近くにあり、かつ値が似ている点は高い重みを受けます。近くにあるが値が異なる点（エッジ）は低い重みを受け、エッジを保持します。

**数式：**

$$w_{ij} = G_s(||p_i - p_j||) \cdot G_r(|I_i - I_j|)$$

ここで：

- $G_s$ は空間ガウシアン（位置に基づく）
- $G_r$ はレンジガウシアン（値の差に基づく）
- $p_i, p_j$ は位置
- $I_i, I_j$ は値（この場合は座標）

**パラメータ：**

| パラメータ   | 型     | デフォルト | 説明                     |
| ------------ | ------ | ---------- | ------------------------ |
| `size`       | number | 5          | カーネルサイズ（奇数）   |
| `sigmaSpace` | number | 自動       | 空間標準偏差             |
| `sigmaValue` | number | 10         | 値標準偏差（エッジ閾値） |

**目安：**

- size 5〜7、sigmaValue 10：標準的な設定。角を保ちつつ滑らか
- size 9以上、sigmaValue 5：強いエッジ保存。角がほぼそのまま残る
- size 11以上、sigmaValue 20以上：ガウシアンに近い動作。角が丸まる

**sigmaValueの理解：**

- **低いsigmaValue：** 強いエッジ保存（点は非常に似ている必要がある）
- **高いsigmaValue：** 弱いエッジ保存（ガウシアンに近づく）

**特性：**

- **エッジ保存：** 鋭角と方向変化を維持
- **適応的：** 自動的にエッジを検出して保存
- **低速：** 他のカーネルより計算量が多い

**使用場面：**

- 鋭角を保持する必要がある場合
- 角度が重要な幾何学的描画
- ガウシアンが角を過度にスムーズにする場合

**例：**

```ts
import { bilateralKernel } from '@stroke-stabilizer/core'

// 強いエッジ保存
const sharp = bilateralKernel({
  size: 7,
  sigmaValue: 5,
})

// 中程度のエッジ保存
const moderate = bilateralKernel({
  size: 7,
  sigmaValue: 15,
})
```

---

## 概念

### FIRフィルタとIIRフィルタ

**FIR（有限インパルス応答）：**

- 出力は現在と過去の入力のみに依存
- 例：移動平均、畳み込みカーネル
- 特性：線形位相、安定、予測可能な遅延

**IIR（無限インパルス応答）：**

- 出力は過去の出力と入力に依存
- 例：EMA、カルマン、One Euro
- 特性：少ない計算で同等のスムージングを達成可能、ただし位相歪みの可能性あり

### 畳み込みとパディング

ポストプロセスは**双方向畳み込み**を使用し、対称的なスムージングのためにカーネルを両方向に適用します。

**パディングモード**はエッジ効果を処理します：

| モード    | 説明                   | 最適な用途                       |
| --------- | ---------------------- | -------------------------------- |
| `reflect` | 境界で値をミラーリング | 最も自然な結果                   |
| `edge`    | エッジ値を繰り返す     | 反射がアーティファクトを作る場合 |
| `zero`    | ゼロでパディング       | エッジをフェードさせたい場合     |

**終点の保存：**

デフォルトでは、`smooth()` はストロークの正確な始点と終点を保存します。これにより、安定化されたストロークがポインタを離した実際の位置に到達することが保証されます。

| オプション          | デフォルト | 説明                                |
| ------------------- | ---------- | ----------------------------------- |
| `preserveEndpoints` | `true`     | 畳み込み後も元の始点/終点を維持する |

**例：**

```ts
import { smooth, gaussianKernel } from '@stroke-stabilizer/core'

// デフォルト：終点が保存される
const smoothed = smooth(points, {
  kernel: gaussianKernel({ size: 7 }),
  padding: 'reflect',
})

// 終点保存を無効化（終点がずれる可能性あり）
const smoothedAll = smooth(points, {
  kernel: gaussianKernel({ size: 7 }),
  padding: 'reflect',
  preserveEndpoints: false,
})
```

---

## フィルタの組み合わせ

### 推奨される組み合わせ

**描画（一般）：**

```ts
pointer
  .addFilter(noiseFilter({ minDistance: 2 }))
  .addFilter(oneEuroFilter({ minCutoff: 1.0, beta: 0.007 }))
```

**高精度：**

```ts
pointer
  .addFilter(noiseFilter({ minDistance: 1 }))
  .addFilter(kalmanFilter({ processNoise: 0.1, measurementNoise: 0.3 }))
  .addPostProcess(gaussianKernel({ size: 5 }))
```

**書道/芸術的：**

```ts
pointer
  .addFilter(stringFilter({ stringLength: 15 }))
  .addFilter(emaFilter({ alpha: 0.4 }))
```

**エッジ保存付き最大スムーズさ：**

```ts
pointer
  .addFilter(oneEuroFilter({ minCutoff: 0.5, beta: 0.01 }))
  .addPostProcess(bilateralKernel({ size: 9, sigmaValue: 8 }))
```
